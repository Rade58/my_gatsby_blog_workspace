# DAKLE NA GROUP PAGE-U ZELIM DA QUERY-UJEM CARD-OVE PREMA DATUMU

MORACU DA IZVRSIM MNOGE MODIFIKACIJE

U SUSTINI NASO SAM BOLJI NACIN DA DOBIJEM NEKI DATA INSIDE RESOLVER A TO JE KORISCENJE 

- `context.nodeModel.runQuery()`

PRE NEGO STO BILO STA URADIS, POGLEDAJ DONJI QUERY

```php
{
	
  allBlogPostPage(
    filter: {groupPage: {name: {eq: "GraphQL"}}},
  	sort: {fields: updated, order: DESC}
  ){
    nodes {
      updated(fromNow: true)
    }
  }
}
```

POGLEDAJ STA SI IZ NJEGA DOBIO

```json
{
  "data": {
    "allBlogPostPage": {
      "nodes": [
        {
          "updated": "4 hours ago"
        },
        {
          "updated": "a day ago"
        }
      ]
    }
  }
}
```

# SADA IDEM DA REDEFINISEM `blogPostPages` RESOLVER NA `GroupPage` TYPE-U

TAK OSTO CU REKREIRATI GORNJI QUERI UZ KORISCENJE `context.nodeModel.runQuery()`

**ONO STA SAM RADIO U POMENUTOM RESOLVERU, RANIJE, BILO JE LOSE, JER SAM UZIMAO NODE PO NODE PREM ID-JU** (ID-JEVE SAM VADIO IZ ONOG NIZA IZ GLOBALNOG OBIMA (I EVENTUALLY, JA ZELIM DA SE OTRASIM TOG NIZA))

## NAKON TOGA CU DEFINISATI INPUT TYPE ZA `blogPostPages`

## NEKE REFERENCE

<https://www.gatsbyjs.org/docs/schema-customization#custom-query-fields>


# JA USTVARI ZELIM DA DEFINISAEM SORTING PREMA DATE-U

# ALI EVO VEC SE JAVIO NOVI PROBLEM, I NOVA POTREBA DA MODIFIKUJEM SCHEMA-A

blogPostPages FIELD NA GroupPage TYPE-U NEMA MOGUCNOST ZA UNOS ARGUMENATA

MORACU TO POPRAVITI

**ZATO MISLIM DA CU OPET MORATI DA DEFINISEM RESOLVER-A, ALI I DIREKTIVU**

# :one: NAKON NEKOLIKO QUERY-JA, SAZNAO SAM, INPUT TYPE-OVE ZA `blogPostPage` I `allBlogPostPage`

`BlogPostPage` TYPE (RETURNED TYPE QUERY-JI blogPostPage I allBlogPostPage) (TO VEC ZNAS)

A JEDAN ON INPUT TYPE-OVA, KOJI ME ZANIMA

**`BlogPostPageSortInput`**

# DAKLE JA USTVARI ZELIM DA FIELDU `blogPostPages`, ZADAJEM ARGUMENT U SKLADU SA POMENUTIM input TYPE-OM

U SUSTINI POTREBNO JE DA TYPE-UJES ARGUMENTE U RESOLVERU, I ZA TO CES ISKORISTITI 

NARAVNO U SKLADU SA TIM JA CU NAPRAVITI QUERY U RESOLVER-U (SA `context.nodeModel.runQuery()`)

# KADA SVE ZAVRSIM, POKAZACU KAKO CE IZGLEDATI RESOLVER

IZKOMENTARISACU STA SAM I ZASTO SAM DEFINISAO

***
***
***
***
***
***

DA TI SAMO NAPOMENEM DA SAM JA U `packages/gatsby-theme-raedal/src/templates/group-page-template.tsx` ZADAO ARGUMENTE PRILIKOM QUERYINGA ZA FIELDOM `blogPostPages`

TAKO JE BIO LAKSI DEVELOPMENT (A ZADAO SAM ARGUMENTE U SKLADU SA `BlogPostPageSortInput` INPUT TYPEOM)

OVAKO MI JE LAKSE DEVELOPMENT, JER MOGU DA STAMPAM ARGS-E U RESOLVERU

# :one: DAKLE JA NISAM PRILIKOM DEFINISANJA RESOLVER-A ZADAO DA ARGUMENTI MORAJU BITI NON NULL

ZATO CU DA HANDLE-UJEM SLUCAJ I KADA NEMA ARGUMENATA

# :two: NEKA TI RESOLVER BUDE ASINHRON JER IZGLEDA DA TI `runQuery` PROIZVODI Promise

I BIO SAM U PRAVU, ZISTA VIDIM DA JE `context.nodeModel.runQuery` ZISTA FUNKCIJA KOJA RETURNUJE Promise RESOLVED SA QUERIED PODACIMA

# :three: DAKLE REKAO SAM DA ZELIM DA ONAJ KOJI VRSI QUERYING OVOG FIELDA DA AKO ODLUCI DA ZADA ARGUMENTE DA TO URADI I AKO NE ODLUCI DA ZADA ARGUMENTE DA TO MZE DA URADI

DAKLE MORAM HANDLE-OVATI OVAKO

- AKO NEMA sort PROPERTIJA NA args OBJEKTU DA SE RUNN-UJE QUERY BEZ ARGUMENATA (SAMO NA OSNOVU `filter: {groupPage: {name: {eq: source.name}}}`) (DAKLE SAMO NA OSNOVU FILTERA PREMA `source.name`)

- A AKO IMA sort PROPERTIJA NA ARGUMENTU, DA SE DAKLE PRI QUERYING-U IZVRSI SIRTING PREMA UPDATED FIELD-U

I TO OD NAJNOVIJEG DATUMA PREMA STARIJIM (DESC)

MOZES POGLEDATI POMENUTI blogPostPages RESOLVER NA GroupPage TYPE-U

# NARAVNO STO SE TICE FILTRIRANHJA, FILTRIRA SE PREMA `groupPage` FIELD-U NA `BlogPostPage` TYPE-U

I ONDA FILTRIRAM TAKO RECI U DUBINU

`filter: {groupPage: {name: {eq: source.name}}}`

DA, ZISTA MI GRAPHQL LAYER GATSBY-JA, TO DOZVOLJAVA

# A STO SE TICE SAMOG SORTING-A ,SORTIRA SE PREMA DATUMU, ODNONO FIELD-U `updated`